import { NextResponse } from "next/server";
import { supabase } from "../../../lib/supabase";

type MoodRow = {
  emoji: string | null;
  label: string | null;
  timestamp: string | null;
  country: string | null;
  region: string | null;
  latitude: number | null;
  longitude: number | null;
  reason?: string | null;
};

function startOfDay(d = new Date()): Date {
  const nd = new Date(d);
  nd.setHours(0,0,0,0);
  return nd;
}

function startOfNDaysAgo(n: number): Date {
  const d = new Date();
  d.setDate(d.getDate() - n);
  return startOfDay(d);
}

function iso(dt: Date): string { return dt.toISOString(); }

async function readData(timeRange: string | null): Promise<MoodRow[]> {
  // timeRange: 'day' | 'week' | 'month' | null (all)
  let fromISO: string | null = null;
  if (timeRange === 'day') {
    fromISO = iso(startOfDay());
  } else if (timeRange === 'week') {
    fromISO = iso(startOfNDaysAgo(6)); // today + previous 6 days = 7 giorni
  } else if (timeRange === 'month') {
    fromISO = iso(startOfNDaysAgo(29)); // 30 giorni
  }

  let query = supabase.from('moods').select('emoji,label,timestamp,country,region,latitude,longitude,reason');
  if (fromISO) {
    query = query.gte('timestamp', fromISO);
  }
  const { data, error } = await query;
  if (error || !data) return [];
  return data as MoodRow[];
}

const countryToContinent: Record<string, string> = {
  US: "North America",
  CA: "North America",
  MX: "North America",
  BR: "South America",
  AR: "South America",
  GB: "Europe",
  FR: "Europe",
  DE: "Europe",
  IT: "Europe",
  ES: "Europe",
  RU: "Europe/Asia",
  CN: "Asia",
  JP: "Asia",
  IN: "Asia",
  AU: "Oceania",
  NZ: "Oceania",
  ZA: "Africa",
  EG: "Africa",
};

function countryCodeToContinent(code?: string | null) {
  if (!code) return "Unknown";
  const up = code.toUpperCase();
  return countryToContinent[up] || "Other";
}

function normalizeReason(r?: string | null): string | null {
  if (!r) return null;
  // Normalize: lowercase, trim, collapse multiple spaces, remove special chars except letters/numbers/spaces
  const cleaned = r.toLowerCase()
    .replace(/[^a-z0-9àèéìòóùç\s]/gi, " ")
    .replace(/\s+/g, " ")
    .trim();
  // Only return if it has meaningful content (at least 2 characters)
  return cleaned.length >= 2 ? cleaned : null;
}

export async function GET(request: Request) {
  try {
    const url = new URL(request.url);
    const debug = url.searchParams.get("debug") === "1";
    const timeRange = url.searchParams.get('timeRange'); // 'day' | 'week' | 'month'
    const arr = await readData(timeRange);

    // Per trending global 24h vs precedenti 24h (indipendente da timeRange principale)
    const now = new Date();
    const from24 = new Date(now.getTime() - 24*60*60*1000);
    const from48 = new Date(now.getTime() - 48*60*60*1000);

    // Query minima per emoji + timestamp
    const { data: last48Data } = await supabase
      .from('moods')
      .select('emoji,timestamp')
      .gte('timestamp', from48.toISOString());
    const last48 = (last48Data || []) as Array<{emoji: string|null; timestamp: string|null}>;
    const countsPrev24: Record<string, number> = {}; // 48->24
    const countsCurr24: Record<string, number> = {}; // 24->0
    for (const r of last48) {
      if (!r.timestamp) continue;
      const ts = new Date(r.timestamp).getTime();
      const emo = r.emoji || 'Unknown';
      if (ts >= from48.getTime() && ts < from24.getTime()) {
        countsPrev24[emo] = (countsPrev24[emo] || 0) + 1;
      } else if (ts >= from24.getTime()) {
        countsCurr24[emo] = (countsCurr24[emo] || 0) + 1;
      }
    }
    const trending: Array<{ mood: string; current: number; previous: number; delta: number; pct: number }> = [];
    const uniqueMoods = new Set<string>([...Object.keys(countsPrev24), ...Object.keys(countsCurr24)]);
    for (const m of uniqueMoods) {
      const cur = countsCurr24[m] || 0;
      const prev = countsPrev24[m] || 0;
      const delta = cur - prev;
      const pct = prev === 0 ? (cur > 0 ? 100 : 0) : ((delta / prev) * 100);
      trending.push({ mood: m, current: cur, previous: prev, delta, pct: Math.round(pct * 10)/10 });
    }
    trending.sort((a,b) => b.pct - a.pct || b.delta - a.delta);
    const topTrending = trending.slice(0, 5);

    const byContinent: Record<string, number> = {};
    const byCountry: Record<string, number> = {};
    const byMood: Record<string, number> = {};
    const byMoodAndContinent: Record<string, Record<string, number>> = {};
    const byCountryMood: Record<string, Record<string, number>> = {};
    const reasonTokens: Record<string, number> = {};
    const reasonByCountry: Record<string, Record<string, number>> = {};

    for (const e of arr) {
      const rawCountry: string | null = e.country || null;
      const country = rawCountry ? rawCountry.toString().trim().toUpperCase() : "Unknown";
      const cont = countryCodeToContinent(country);
      const mood = e.emoji || e.label || "Unknown";

      byContinent[cont] = (byContinent[cont] || 0) + 1;
      byCountry[country] = (byCountry[country] || 0) + 1;
      if (!byCountryMood[country]) { byCountryMood[country] = {}; }
      byCountryMood[country][mood] = (byCountryMood[country][mood] || 0) + 1;
      byMood[mood] = (byMood[mood] || 0) + 1;
      if (!byMoodAndContinent[cont]) { byMoodAndContinent[cont] = {}; }
      byMoodAndContinent[cont][mood] = (byMoodAndContinent[cont][mood] || 0) + 1;

      // reason tokenization (globale)
      if ((e as any).reason) {
        const toks = tokenizeReason((e as any).reason);
        for (const t of toks) {
          reasonTokens[t] = (reasonTokens[t] || 0) + 1;
        }
        // reason per paese
        if (!reasonByCountry[country]) { reasonByCountry[country] = {}; }
        for (const t of toks) {
          reasonByCountry[country][t] = (reasonByCountry[country][t] || 0) + 1;
        }
      }
    }

    // compute top tokens globali (limit 100)
    const topReasonTokens = Object.entries(reasonTokens)
      .sort((a,b) => b[1] - a[1])
      .slice(0,100)
      .map(([token,count]) => ({ token, count }));

    // compute top tokens per paese (limit 50)
    const reasonCloudByCountry: Record<string, Array<{token: string; count: number}>> = {};
    for (const [country, tokens] of Object.entries(reasonByCountry)) {
      reasonCloudByCountry[country] = Object.entries(tokens)
        .sort((a,b) => b[1] - a[1])
        .slice(0,50)
        .map(([token,count]) => ({ token, count }));
    }

    const payload: any = {
      total: arr.length,
      byContinent,
      byCountry,
      byMood,
      byMoodAndContinent,
      byCountryMood,
      reasonCloud: topReasonTokens,
      reasonCloudByCountry,
      timeRange: timeRange || 'all',
      trending24h: topTrending,
    };
    if (debug) {
      payload.__debug = {
        source: "supabase",
        exists: arr.length > 0,
        countriesPresent: Object.keys(byCountry),
        sampleFirst: arr.slice(0,3)
      };
    }
    return NextResponse.json(payload);
  } catch (err) {
    return NextResponse.json({
      total: 0,
      byContinent: {},
      byCountry: {},
      byMood: {},
      byMoodAndContinent: {},
      byCountryMood: {},
      reasonCloud: [],
      reasonCloudByCountry: {},
      error: String(err)
    }, { status: 500 });
  }
}
